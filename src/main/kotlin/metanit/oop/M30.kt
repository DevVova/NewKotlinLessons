package metanit.oop

//Вот так можно к переменным верхнего уровня добавлять тоже модификатор.
internal val hello = "Hello"//Здесь модификатор доступа внутри модуля.
/**
 * Все используемые типы, а также компоненты типов (классы, объекты, интерфейсы,
 * конструкторы, функции, свойства) имеют определенный уровень видимости,
 * определяемый модификатором видимости (модификатором доступа). Модификатор
 * видимости определяет, где те или иные типы и их компоненты доступны и где
 * их можно использовать. В Kotlin есть следующие модификаторы видимости:
 *
 * Private: классы, объекты, интерфейсы, а также функции и свойства, определенные
 * вне класса, с этим модификатором видны только в том файле, в котором они
 * определены. Члены класса с этим модификатором видны только в рамках своего класса.
 *
 * Protected: члены класса с этим модификатором видны в классе, в котором они
 * определены, и в классах-наследниках.
 *
 * Internal: классы, объекты, интерфейсы, функции, свойства, конструкторы
 * с этим модификатором видны в любой части модуля, в котором они определены.
 * Модуль представляет набор файлов Kotlin, скомпилированных вместе в одну
 * структурную единицу. Это может быть модуль IntelliJ IDEA или проект Maven.
 *
 * Public: классы, функции, свойства, объекты, интерфейсы с этим модификатором
 * видны в любой части программы. (При этом если функции или классы с этим
 * модификатором определены в другом пакете их все равно нужно импортировать).
 */
fun main() {
    val audi = SuperCar(33000, "grey")
    audi.info()

    val myOrder = MyOrder(1, 45)
    myOrder.about()
    myOrder.aboutMy()
    println(myOrder.lot)
    println(hello)
}

//Если модификатор видимости явным образом не указан, то применяется модификатор public.
//Ниже у свойств объявленных в первичном конструкторе, модификатор также будет public.
class SuperCar(val price: Int, val color: String) {
    fun info() {
        println("It's a super car. Its color is $color. Its price is $price.")
    }
}

//Ниже класс который мы не можем использовать для создания объекта, но можем унаследовать.
//Через вторичный конструктор, который у нас protected.
open class Order private constructor(val lot: Int) {
    var num = 0
    protected constructor(lotP: Int, numberP: Int) : this(lotP) {
        num = numberP
    }
    private fun getNumber() {
        println("Its number is $num.")
    }
    fun about() {
        println("It is an order.")
        getNumber()
    }
}

class MyOrder(myLot: Int, myNum: Int) : Order(myLot, myNum) {
    fun aboutMy() {
        super.about()
        println("It is MyOrder.")
    }
}